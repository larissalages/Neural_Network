{"changed":true,"filter":false,"title":"scriptMatlba.m","tooltip":"/scriptMatlba.m","value":"echo on\nclear\n\n%    Informacoes sobre a rede e os dados\nnumEntradas   = 46;     % Numero de nodos de entrada\nnumEscondidos = 5;     % Numero de nodos escondidos\nnumSaidas     = 2;     % Numero de nodos de saida\nnumTr         = 40300;   % Numero de padroes de treinamento\nnumVal        = 20150;    % Numero de padroes de validacao\nnumTeste      = 10175;    % Numero de padroes de teste\n\necho off\n\n%    Abrindo arquivos \narquivoTreinamento = fopen('Treinamento.txt','rt');  \narquivoValidacao   = fopen('Validacao.txt','rt');    \narquivoTeste       = fopen('Teste.txt','rt');        \n\n%    Lendo arquivos e armazenando dados em matrizes\ndadosTreinamento    = fscanf(arquivoTreinamento,'%f',[(numEntradas + numSaidas), numTr]);   % Lendo arquivo de treinamento\nentradasTreinamento = dadosTreinamento(1:numEntradas, 1:numTr);\nsaidasTreinamento   = dadosTreinamento((numEntradas + 1):(numEntradas + numSaidas), 1:numTr);       \n\ndadosValidacao      = fscanf(arquivoValidacao,'%f',[(numEntradas + numSaidas), numVal]);    % Mesmo processo para validacao\nentradasValidacao   = dadosValidacao(1:numEntradas, 1:numVal);\nsaidasValidacao     = dadosValidacao((numEntradas + 1):(numEntradas + numSaidas), 1:numVal);\n\ndadosTeste          = fscanf(arquivoTeste,'%f',[(numEntradas + numSaidas), numTeste]);      % Mesmo processo para teste\nentradasTeste       = dadosTeste(1:numEntradas, 1:numTeste);\nsaidasTeste         = dadosTeste((numEntradas + 1):(numEntradas + numSaidas), 1:numTeste);\n\n%    Fechando arquivos\nfclose(arquivoTreinamento);\nfclose(arquivoValidacao);\nfclose(arquivoTeste);\n\n%   Criando a rede (para ajuda, digite 'help newff')\n\nfor entrada = 1 : numEntradas;  % Cria 'matrizFaixa', que possui 'numEntradas' linhas, cada uma sendo igual a [0 1].\n     matrizFaixa(entrada,:) = [0 1];  \nend\n\nrede = newff(matrizFaixa,[numEscondidos numSaidas],{'tansig','tansig'},'traingdm','learngdm','mse');\n% matrizFaixa                    : indica que todas as entradas possuem valores na faixa entre 0 e 1\n% [numEscondidos numSaidas]      : indica a quantidade de nodos escondidos e de saida da rede\n% {'logsig','logsig'}            : indica que os nodos das camadas escondida e de saida terao funcao de ativacao sigmoide logistica\n% 'traingdm','learngdm'          : indica que o treinamento vai ser feito com gradiente descendente (backpropagation)\n% 'sse'                          : indica que o erro a ser utilizado vai ser SSE (soma dos erros quadraticos)\n\n% Inicializa os pesos da rede criada (para ajuda, digite 'help init')\nrede = init(rede);\necho on\n%   Parametros do treinamento (para ajuda, digite 'help traingd')\nrede.trainParam.epochs   = 10000;    % Maximo numero de iteracoes\nrede.trainParam.lr       = 0.2;  % Taxa de aprendizado\nrede.trainParam.goal     = 0;      % Criterio de minimo erro de treinamento\nrede.trainParam.max_fail = 10;      % Criterio de quantidade maxima de falhas na validacao\nrede.trainParam.min_grad = 0;      % Criterio de gradiente minimo\nrede.trainParam.show     = 10;     % Iteracoes entre exibicoes na tela (preenchendo com 'NaN', nao exibe na tela)\nrede.trainParam.time     = inf;    % Tempo maximo (em segundos) para o treinamento\necho off\nfprintf('\\nTreinando ...\\n')\n\nconjuntoValidacao.P = entradasValidacao; % Entradas da validacao\nconjuntoValidacao.T = saidasValidacao;   % Saidas desejadas da validacao\n\n%   Treinando a rede\n[redeNova,desempenho,saidasRede,erros] = train(rede,entradasTreinamento,saidasTreinamento,[],[],conjuntoValidacao);\n% redeNova   : rede apos treinamento\n% desempenho : apresenta os seguintes resultados\n%              desempenho.perf  - vetor com os erros de treinamento de todas as iteracoes (neste exemplo, escolheu-se erro SSE)\n%              desempenho.vperf - vetor com os erros de validacao de todas as iteracoes (idem)\n%              desempenho.epoch - vetor com as iteracoes efetuadas\n% saidasRede : matriz contendo as saidas da rede para cada padrao de treinamento\n% erros      : matriz contendo os erros para cada padrao de treinamento\n%             (para cada padrao: erro = saida desejada - saida da rede)\n% Obs.       : Os dois argumentos de 'train' preenchidos com [] apenas sao utilizados quando se usam delays\n%             (para ajuda, digitar 'help train')\n\nfprintf('\\nTestando ...\\n');\n\n%    Testando a rede\n[saidasRedeTeste,Pf,Af,errosTeste,desempenhoTeste] = sim(redeNova,entradasTeste,[],[],saidasTeste);\n% saidasRedeTeste : matriz contendo as saidas da rede para cada padrao de teste\n% Pf,Af           : matrizes nao usadas neste exemplo (apenas quando se usam delays)\n% errosTeste      : matriz contendo os erros para cada padrao de teste\n%                  (para cada padrao: erro = saida desejada - saida da rede)\n% desempenhoTeste : erro de teste (neste exemplo, escolheu-se erro SSE)\n\nfprintf('MSE para o conjunto de treinamento: %6.5f \\n',desempenho.perf(length(desempenho.perf)));\nfprintf('MSE para o conjunto de validacao: %6.5f \\n',desempenho.vperf(length(desempenho.vperf)));\nfprintf('MSE para o conjunto de teste: %6.5f \\n',desempenhoTeste);\n\n%     Calculando o erro de classificacao para o conjunto de teste\n%     (A regra de classificacao e' winner-takes-all, ou seja, o nodo de saida que gerar o maior valor de saida\n%      corresponde a classe do padrao).\n%     Obs.: Esse erro so' faz sentido se o problema for de classificacao. Para problemas que nao sao de classificacao,\n%           esse trecho do script deve ser eliminado.\n\n[maiorSaidaRede, nodoVencedorRede] = max (saidasRedeTeste);\n[maiorSaidaDesejada, nodoVencedorDesejado] = max (saidasTeste);\n\n%      Obs.: O comando 'max' aplicado a uma matriz gera dois vetores: um contendo os maiores elementos de cada coluna\n%            e outro contendo as linhas onde ocorreram os maiores elementos de cada coluna.\n\nclassificacoesErradas = 0;\n\nfor padrao = 1 : numTeste;\n    if nodoVencedorRede(padrao) ~= nodoVencedorDesejado(padrao),\n        classificacoesErradas = classificacoesErradas + 1;\n    end\nend\n\nerroClassifTeste = 100 * (classificacoesErradas/numTeste);\n\nfprintf('Erro de classificacao para o conjunto de teste: %6.5f\\n',erroClassifTeste);","undoManager":{"mark":-2,"position":0,"stack":[[{"start":{"row":0,"column":0},"end":{"row":115,"column":84},"action":"insert","lines":["echo on","clear","","%    Informacoes sobre a rede e os dados","numEntradas   = 46;     % Numero de nodos de entrada","numEscondidos = 5;     % Numero de nodos escondidos","numSaidas     = 2;     % Numero de nodos de saida","numTr         = 40300;   % Numero de padroes de treinamento","numVal        = 20150;    % Numero de padroes de validacao","numTeste      = 10175;    % Numero de padroes de teste","","echo off","","%    Abrindo arquivos ","arquivoTreinamento = fopen('Treinamento.txt','rt');  ","arquivoValidacao   = fopen('Validacao.txt','rt');    ","arquivoTeste       = fopen('Teste.txt','rt');        ","","%    Lendo arquivos e armazenando dados em matrizes","dadosTreinamento    = fscanf(arquivoTreinamento,'%f',[(numEntradas + numSaidas), numTr]);   % Lendo arquivo de treinamento","entradasTreinamento = dadosTreinamento(1:numEntradas, 1:numTr);","saidasTreinamento   = dadosTreinamento((numEntradas + 1):(numEntradas + numSaidas), 1:numTr);       ","","dadosValidacao      = fscanf(arquivoValidacao,'%f',[(numEntradas + numSaidas), numVal]);    % Mesmo processo para validacao","entradasValidacao   = dadosValidacao(1:numEntradas, 1:numVal);","saidasValidacao     = dadosValidacao((numEntradas + 1):(numEntradas + numSaidas), 1:numVal);","","dadosTeste          = fscanf(arquivoTeste,'%f',[(numEntradas + numSaidas), numTeste]);      % Mesmo processo para teste","entradasTeste       = dadosTeste(1:numEntradas, 1:numTeste);","saidasTeste         = dadosTeste((numEntradas + 1):(numEntradas + numSaidas), 1:numTeste);","","%    Fechando arquivos","fclose(arquivoTreinamento);","fclose(arquivoValidacao);","fclose(arquivoTeste);","","%   Criando a rede (para ajuda, digite 'help newff')","","for entrada = 1 : numEntradas;  % Cria 'matrizFaixa', que possui 'numEntradas' linhas, cada uma sendo igual a [0 1].","     matrizFaixa(entrada,:) = [0 1];  ","end","","rede = newff(matrizFaixa,[numEscondidos numSaidas],{'tansig','tansig'},'traingdm','learngdm','mse');","% matrizFaixa                    : indica que todas as entradas possuem valores na faixa entre 0 e 1","% [numEscondidos numSaidas]      : indica a quantidade de nodos escondidos e de saida da rede","% {'logsig','logsig'}            : indica que os nodos das camadas escondida e de saida terao funcao de ativacao sigmoide logistica","% 'traingdm','learngdm'          : indica que o treinamento vai ser feito com gradiente descendente (backpropagation)","% 'sse'                          : indica que o erro a ser utilizado vai ser SSE (soma dos erros quadraticos)","","% Inicializa os pesos da rede criada (para ajuda, digite 'help init')","rede = init(rede);","echo on","%   Parametros do treinamento (para ajuda, digite 'help traingd')","rede.trainParam.epochs   = 10000;    % Maximo numero de iteracoes","rede.trainParam.lr       = 0.2;  % Taxa de aprendizado","rede.trainParam.goal     = 0;      % Criterio de minimo erro de treinamento","rede.trainParam.max_fail = 10;      % Criterio de quantidade maxima de falhas na validacao","rede.trainParam.min_grad = 0;      % Criterio de gradiente minimo","rede.trainParam.show     = 10;     % Iteracoes entre exibicoes na tela (preenchendo com 'NaN', nao exibe na tela)","rede.trainParam.time     = inf;    % Tempo maximo (em segundos) para o treinamento","echo off","fprintf('\\nTreinando ...\\n')","","conjuntoValidacao.P = entradasValidacao; % Entradas da validacao","conjuntoValidacao.T = saidasValidacao;   % Saidas desejadas da validacao","","%   Treinando a rede","[redeNova,desempenho,saidasRede,erros] = train(rede,entradasTreinamento,saidasTreinamento,[],[],conjuntoValidacao);","% redeNova   : rede apos treinamento","% desempenho : apresenta os seguintes resultados","%              desempenho.perf  - vetor com os erros de treinamento de todas as iteracoes (neste exemplo, escolheu-se erro SSE)","%              desempenho.vperf - vetor com os erros de validacao de todas as iteracoes (idem)","%              desempenho.epoch - vetor com as iteracoes efetuadas","% saidasRede : matriz contendo as saidas da rede para cada padrao de treinamento","% erros      : matriz contendo os erros para cada padrao de treinamento","%             (para cada padrao: erro = saida desejada - saida da rede)","% Obs.       : Os dois argumentos de 'train' preenchidos com [] apenas sao utilizados quando se usam delays","%             (para ajuda, digitar 'help train')","","fprintf('\\nTestando ...\\n');","","%    Testando a rede","[saidasRedeTeste,Pf,Af,errosTeste,desempenhoTeste] = sim(redeNova,entradasTeste,[],[],saidasTeste);","% saidasRedeTeste : matriz contendo as saidas da rede para cada padrao de teste","% Pf,Af           : matrizes nao usadas neste exemplo (apenas quando se usam delays)","% errosTeste      : matriz contendo os erros para cada padrao de teste","%                  (para cada padrao: erro = saida desejada - saida da rede)","% desempenhoTeste : erro de teste (neste exemplo, escolheu-se erro SSE)","","fprintf('MSE para o conjunto de treinamento: %6.5f \\n',desempenho.perf(length(desempenho.perf)));","fprintf('MSE para o conjunto de validacao: %6.5f \\n',desempenho.vperf(length(desempenho.vperf)));","fprintf('MSE para o conjunto de teste: %6.5f \\n',desempenhoTeste);","","%     Calculando o erro de classificacao para o conjunto de teste","%     (A regra de classificacao e' winner-takes-all, ou seja, o nodo de saida que gerar o maior valor de saida","%      corresponde a classe do padrao).","%     Obs.: Esse erro so' faz sentido se o problema for de classificacao. Para problemas que nao sao de classificacao,","%           esse trecho do script deve ser eliminado.","","[maiorSaidaRede, nodoVencedorRede] = max (saidasRedeTeste);","[maiorSaidaDesejada, nodoVencedorDesejado] = max (saidasTeste);","","%      Obs.: O comando 'max' aplicado a uma matriz gera dois vetores: um contendo os maiores elementos de cada coluna","%            e outro contendo as linhas onde ocorreram os maiores elementos de cada coluna.","","classificacoesErradas = 0;","","for padrao = 1 : numTeste;","    if nodoVencedorRede(padrao) ~= nodoVencedorDesejado(padrao),","        classificacoesErradas = classificacoesErradas + 1;","    end","end","","erroClassifTeste = 100 * (classificacoesErradas/numTeste);","","fprintf('Erro de classificacao para o conjunto de teste: %6.5f\\n',erroClassifTeste);"],"id":1}]]},"ace":{"folds":[],"scrolltop":353,"scrollleft":0,"selection":{"start":{"row":54,"column":11},"end":{"row":54,"column":11},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":22,"state":"start","mode":"ace/mode/objectivec"}},"timestamp":1446476724106}